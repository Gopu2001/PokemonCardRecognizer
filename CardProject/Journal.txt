So far, Django seems to be a very different beast than what I am used to conquering. So, let's walk through it. My project is titled "PokemonCardRecognition". Even though it is a lame name, I'll leave it for now and probably change it later. The model was built already and the training has come out really well! I am actually pretty surprised at how good it is. While it can be inaccurate on some pictures, those can be fleshed out after getting some parts to the Django part of the project working. The Django project is titled "CardProject" (that'll be changed later, most definitely!). Inside the "CardProject" directory, which is inside the "PokemoncardRecognition" directory, there are three files and one more folder titled "CardProject" (to be covered in a bit). One of the files is "db.sqlite3", which holds all the data information Django needs to handle events, such as logins and authentications as well as permissions and session information. These tables are listed below (as retrieved with the sqlite3 ".tables" command):

auth_group					~ authorizations for groups (ie,Admin, Users)
auth_group_permissions		~ permissions for these groups
auth_permission				~ permissions list associated with auth level
auth_user					~ permissions for specific users
auth_user_groups			~ permissions for groups of users
auth_user_user_permissions	~ permissions from user to user
django_admin_log			~ displays admin log in times
django_content_type			~ displays app labels and the model type
django_migrations			~ information about migrations
django_session				~ information about sessions

While I have absolutely no idea how to use these tables, I am happe to see that if I have any sql tables, I can use that same table that Django is currently using. Also, I can see under django_migrations, date information is displayed in Universal Time, not my local time zone. It might be beneficial to keep it like that until I get confused more than once though. In the manage.py file, the entire thing is run with a single import "execute_from_command_line(sys.argv)". This file would be the one that I would call whenever I make a change to a view in an app on the website. This is also the file that I would call when I want to run the server. However, this running of the server is simplified with a smaller "sudo"-enabled command "run.sh", something I wrote. This run.sh file would allow me to run the django server so that anyone in my network can access the website from any IP that my AGX has.

Inside the "CardProject" folder, there are some more files: "asgi.py", "__init__.py", "settings.py", "urls.py", and "wsgi.py". ASGI and WSGI appears to have the exact same code except for that one character. In theory, ASGI is pretty much the same as WSGI, however, the primary difference between these two servers is that ASGI extends WSGI by utilizing WebSockets. It helps to know that WSGI is laid out as "Web Server Gateway Interface", which was developed specifically for the Python programming language. WSGI is designed based on the CGI standard, which stands for "Common Gateway Interface". The two parts to a WSGI is the server/gateway and the other is an application (or application framework). An ASGI framework is laid out as "Asynchronous Server Gateway Interface", which, as I learned through working with on a project with POINT, implies the usage of websockets. ASGI was designed to be a closer representation of what modern-day web programming looks like. The __init__.py file, while it exists, is completely empty, probably as a placeholder when some file from this directory is imported. It also lets Python know that this directory should be treated as a module. The second to last file in this directory to summarize is "settings.py". This file allows me to change the django settings for the project and is by far the current file that has the most lines of code. It is a bit daunting to look through them all, but it is not actually that bad. In this file, a SECRET_KEY is defined, which means that I have to be careful about what commits I make to my github repository and who has access to the github repository. There is also a boolean flag for a debug mode, however, I do not see that flag being used anywhere else in this file. We can also set the allowed hosts in this file. This means that on my laptop, I can say that whenever I go to "test.com" or "anmol-agx", I get redirected to this django site (and that goes for anywhere on my network!). The settings python file also goes over some installed apps (by apps, I mean stuff like "admin", "auth", "contenttypes", "sessions", etc.). There's also a list of middleware, but I am not so sure about how to handle this part, so I guess I'll just keep it as is. The base name for my url configureation was automatically set to "CardProject.urls". The "CardProject" part in that meant inside the second CardProject folder of the project. There are a list of django templates defined (length 1, but whatever), as well as the database static variable and some authentication password validators. I can also see that there are language codes as well as timezone information. Also, AHA! I see that we define the static folder at the root directory and that's where we place HTML, JS, and CSS files. There is also something called a default auto field. According to the documentation link, I can see that this variable is used whenever a primary key is defined inside a SQL backend table.

Ahhh. So after my first biggest day working on this Django project, I got some cool updates! The first and largest update goes to learning a lot more about the intricacies of what Django is and how to maneuver through it. My first step after the last update I made to this journal was to create an app which allows me to setup an image uploading web application. I learned how when you create a new Model in models.py, which, in this case, was creating a new model for a form to be displayed through a view, you must run `python3 manage.py makemigrations cardAnalysis` (cardAnalysis is the name of the web application I initiated for uploading the Pokemon card images) and then the subsequent command: `python3 manage.py migrate`. I now know that whenever I come across a problem that is not on my end, the Django user end, I need to run these commands at the base directory of the Django project. The prime example of an error that I came across was with there being a SQL no table found error. Apparently, during the migrations step, the backend creates a new SQL table for every new Model I describe in models.py. By the way, I remember seeing this migration information in the migrations folder inside the cardAnalysis web application directory. The biggest and best result of all of this learning was that I was able to create a view where a client could upload six images (preferably Pokemon cards, but I have no idea how to validate whether or not each image actually is a Pokemon card... That can probably be set aside as a task for later). After clicking an "Upload" button, these six images are displayed on the website. I also ensured that these images were actually saved in the "{BASE_DIR}/media/images/" directory. I am feeling so good about this project so far! There are so many next steps to this project, but the first one is not one that you might think it is. I was hoping that instead of starting right at the predictions for what that uploaded image should be recognized as (importing the TensorFlow model that I trained in the first step of this project), I could go for creating a portal for where users can upload and save their images by their account name and profile. As such, each user would be able to create their own profile and view the images they uploaded some time before. Ahhh... this project is coming along so nicely!
